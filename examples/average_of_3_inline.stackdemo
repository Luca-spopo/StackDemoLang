//Shows math operations, some stack usage, and subprocedure call

define_procedure sum_of_3
contract
{
    I promise to pop 3 elements (two numbers to sum) and push 1 element (their sum) on the stack
    I promise to preserve the value of all registers except: registers[0], registers[1], registers[2]
}
body
{
    //Get the arguments
    registers[2] = stack.pop() (as number_to_sum_3)
    registers[1] = stack.pop() (as number_to_sum_2)
    registers[0] = stack.pop() (as number_to_sum_1)

    //Add the first two numbers:
        //Push the first two numbers to the stack
        stack.push(registers[0]) (as number_to_add_1)
        stack.push(registers[1]) (as number_to_add_2)

        //Process the two numbers on top of the stack
        add

        //Get the added value from the top of the stack
        registers[0] = stack.pop() (as sum_of_first_two)

    //Add the third number to the intermediate sum:
        //Push the first two numbers to the stack
        stack.push(registers[0]) (as sum_of_first_two)
        stack.push(registers[2]) (as number_to_add_3)

        //Process the two numbers on top of the stack
        add

        //Get the added value from the top of the stack
        registers[0] = stack.pop() (as total_sum)

    //Push the sum to the stack, as promised by our contract
    stack.push(registers[0]) (as sum)
}

define_procedure average_of_3
contract
{
    I promise to pop 3 elements (the numbers to average) and push 1 element (their average) on the stack
    I promise to preserve the value of all registers except: registers[0], registers[1], registers[2]
}
body
{
    //Get the arguments
    registers[2] = stack.pop() (as number_to_average_3)
    registers[1] = stack.pop() (as number_to_average_2)
    registers[0] = stack.pop() (as number_to_average_1)

    //Sum the numbers using a macro:
        //Prepare the arguments (the numbers to sum) for the subroutine
        stack.push(registers[0]) (as number_to_sum_1)
        stack.push(registers[1]) (as number_to_sum_2)
        stack.push(registers[2]) (as number_to_sum_3)

        //expand the subroutine
        #inline sum_of_3

        //Process the output of the subroutine, which it left for us on the stack
        registers[0] = stack.pop() (as sum)

    //Divide the sum by 3
        //Push the divident and divisor
        stack.push(registers[0]) (as sum)
        stack.push(3) (as diviser)

        //Process the two numbers at the top of the stack
        divide

        //Get the divided value
        registers[0] = stack.pop() (as average)

    //Push the sum to the stack, as promised by our contract
    stack.push(registers[0]) (as average)
}

define_procedure main
body
{
    #LABEL: .loopStart

    input
    input
    input

    registers[2] = stack.pop() (as number_to_average_3)
    registers[1] = stack.pop() (as number_to_average_2)
    registers[0] = stack.pop() (as number_to_average_1)

    //Average the numbers using a macro:
        //Prepare the arguments (the numbers to average) for the subroutine
        stack.push(registers[0]) (as number_to_average_1)
        stack.push(registers[1]) (as number_to_average_2)
        stack.push(registers[2]) (as number_to_average_3)

        //Jump to the subroutine
        #inline average_of_3

        //Process the output of the subroutine, which it left for us on the stack
        registers[0] = stack.pop() (as average)

    //Print the output
    print registers[0] (as average_of_3)

    jump to #.loopStart.lineNumber
    //Or alternatively, jump to #main.lineNumber
}